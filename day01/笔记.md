## 一、了解git
## 1、什么是版本控制
## 1）、常用的版控工具
<!--            -**Git**
                -**SVN**
                -**CVS**
                -**VSS**
                -**TFS**
                -Visual Studio Online 
-->
## 2）、版控分类
<!--
                **1、本地版本控制**
                  记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。
                **2、集中版本控制  SVN**
                  总结: 1. 所有的历史代码都存放在服务器中,一旦服务器崩溃,代码就会丢失,且不能找回
​	               优点: 1. 个人本地占用储存空间较小,只需要保存自己修改的内容即可
                **3、分布式版本控制 	Git**
                  每个人都拥有全部的代码！安全隐患！
                所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。
                不会因为服务器损坏或者网络问题，造成不能工作的情况！
 -->


## 2、常用的linux指令
<!--    1）cd : 进入目录。
        2）cd . . 回退到上一个目录，直接cd进入默认目录
        3）pwd : 显示当前所在的目录路径。
        4）ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。（Mac只有ll）
        5）touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。
        6）rm:  删除一个文件, rm index.js 就会把index.js文件删除。
        7）mkdir:  新建一个目录,就是新建一个文件夹。
        8）rm -r :  删除一个文件夹, rm -r src 删除src目录
        9）mv 移动文件, mv index.html src。 index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。
        10）reset 重新初始化终端/清屏。
        11）clear 清屏。
        12）history 查看命令历史。
        13）help 帮助。（Mac除外）
        14）exit 退出。
        15）#表示注释
        16) ls: 查看桌面的所有文件
-->
<!-- 
Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域 
-->

## 本地仓库搭建
<!-- 
1、创建全新的仓库，需要用GIT管理的项目的根目录执行：
# 在当前目录新建一个Git代码库$ git init
2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。
1:windows查看隐藏文件夹 在查看里面勾选
2:mac查看隐藏文件夹 
``` -->

## 克隆远程仓库
<!-- 
1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！
# 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url] 
2、去 gitee 或者 github 上克隆一个测试！
-->


## Git文件操作
## 文件的四种状态
<!--
1、Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.
    2、Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件
    3、Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !
    4、Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified
-->

# 查看文件状态
# 查看指定文件状态git status [filename]
# 查看所有文件状态git status
# git add .                  添加所有文件到暂存区# git commit -m "消息内容"    提交暂存区中的内容到本地仓库 -m 提交信息
```

- ## 1、数据类型

  ##    1. 基本数据类型

  <!-- number、string、undefined、null、boolean、symbol、bigint --> 

  ## 2.引用数据类型【对象类型】
  
  <!-- (1) 标准普通对象: object
  
  (2) 标准特殊对象： Array、RegExp、Date、Math、Error...
  
  (3) 非标准特殊对象：Number、String、Boolean...
  
  (4) 可调用对象/执行对象：function
  
  简单来说: 数据类型分为基本数据类型和复杂数据类型 -->
  
  ## 3、数据类型的转换  
  
  ## 有两种：一种是隐式转换，一种是显示转换
  
     <!-- 隐式转换： 
        1.Number 只能转换数字 任意不是数字的都会是NaN  （默认转换）
     显示转换：
        1.手动用Number转换
          转换规则：1.字符串转换为数字：空字符串变为0，如果出现任何非有效数字字符，结果都是NaN
                   2.布尔值转换为数字:true–>1,false–>0
                   3.null–>0,undefined–>NaN
                   4.Symbol无法转换为数字，会报错:Uncaught TypeError:Cannot convert a Symbol value to a number
                   5.BigInt去除"n"
                   6.把对象转换为数字{   Date()对象转Number
                                       Number对象转Number
                                       []转Number           }
        2.parseInt与parseFloat
            转换规则：从val字符串左侧第一个字符开始查找，查找出符合radix进制的值（遇到不符合的则结束查找，无论后面是否还有符合的），把找       的内容按照radix进制，转换为10进制！！！
        3.String
           转换规则：除对象以外，都是直接用字符串包起来 
        4.运算符
          除了数学运算，还可能代表字符串拼接，也会发生字符串转换
        5.Boolean
          转换规则：
              除了“0/NaN/空字符串/null/undefined"五个值是false，其余值都是true
           -->
  
  ## 4、检测数据类型
  
  <!-- 
      1.typeof
          typeof 返回对应类型的字符串
          总结：typeof 检测基本数据类型比较准，null检测为object不代表它是引用数据类型，null为空是特殊的基本数据类型，引用数据类型都为 object，内置构造函数和函数都为 function
      2.instanceof
          instanceof 检测类型返回布尔值
          总结：instanceof 不能检测基本数据类型，判断前者的 proto 是否在后者的原型对象上
      3.constructor
          constructor 返回构造函数
          总结：返回当前值的构造函数，比如向 [] 数组这种，都是通过 new Array() 这样去创建实例的，这个 Array 就是数组的构造函数
      4.Object.prototype.toString.call()
          这个方法查的特别的准，可以检查任意类型
   5.Object.getPrototypeOf()这个方法获取原型对比-->
  
   <!--
  typeof：这种方法只能检测基本数据类型，null 和对象的不准
  instanceof：只要是基本数据类型检测就是false，只要是引用数据类型，并且右边是 Object 就是true，可以很好的区分是哪一大类型
  constructor：可以检查基本和引用数据类型，但是可以被修改，有一定的缺陷
  Object.prototype.toString.call()：这种方式是最准的，什么类型都可以检测
  Object.getPrototypeOf()：这种方法获取原型
  -->
  
  ##  5、作用域及作用域链
  
  <!--
      所谓作用域通俗点讲就是变量的可作用范围。
      一般有三种作用域。全局，函数，块。
      分为全局和局部作用域
  
  
  
    1. 变量提升
       变量提升是指将变量声明提升到它所在的作用域的最开始部分
        2.函数提升
       创建函数有两种形式，一种是函数声明，另外一种是函数字面量，只有函数声明才有变量提升
        3.函数提升与变量提升的优先级
       由此可见函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖
         -->
  
  ## 6、字符串
  
  <!-- 
      1.length    代表字符串长度
      2.chanAt() 返回指定位置的字符
          字符串中，字符的位置也是从0开始，依次递增
      3.concat() 用于拼接两个或多个字符串
          不会修改原字符串，会将拼接好的字符串以返回值的方式返回出来
      4.indexOf() 查找从前往后
          可以在字符串中查找指定的字符。
          可以查到的的话返回值字符所在的位置。
          查不到返回 -1。
          如果要查找的字符在字符中存在多个，永远只找一个
      5.lastindexOf() 查找从后往前
          使用方法和 indexOf 一样。但是 indexOf 是从前往后查找，lastindexOf() 是从后往前查找。
      6.replace() 替换
          有两个参数。第一个参数，旧的字符。第二个参数，新的字符。不会修改原数组。会将替换好的数组以返回值的形式返回出来。如果旧的字符在字符串中不止一个，则替换第一个。
      7.split()   将字符串转化成字符串数组
          不会改变原数组。会将转化好的数组以返回值的形式返回出来 。
      8.substr()   字符串的截取
      9.substr()   字符串的指定位置的截取
      10.toLowerCase()  大写字母转小写字母
      11.toUpperCase() 小写字母转大写字母
   -->
  
  ## 运算符
  
  <!-- 
      1.数学运算符
          数学运算符就是常见的**加(+)、减(-)、乘(*)、除(/)、等于(=)、求幂(**)、自增(++)、自减(--)、加等于(+=)、减等于(-=)等
      2.比较运算符
          与数学运算中的比较相同**：大于(>)、小于(<)、大于等于(>=)、小于等于(<=)、相等(==)、全等(===)、不等(!=)、不全等(!==)等；注意: 全等不光比较两者值是否相同，还比较变量类型是否相同；不全等也是一样
      3.三元表达式
          三元表达式可以替代简单的if条件，表达式为判断条件 ？条件为真 ：条件为假
      4.短路运算符 && 与 ||
          短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了
      
   -->
  
  **1.** ***\*数组的操作方法\****
  
  ***\*操作数组本身的--数组的内置操作方法  7个\****
  
  push 尾部添加，返回新数组的长度
  
  pop 尾部删除，返回的是被删除的元素
  
  shift  头部删除
  
  unshift 头部添加
  
  sort - 排序，返回排序后的数组
  
  splice -- 增/删/改，数组.splice(下标，长度，替换的)
  
  reverse  反转数组
  
   
  
  ***\*操作方法\****
  
  循环遍历数组 forEach  -- 对数组进行循环遍历
  
   filter -- 数组过滤  返回 所有符合条件的元素 一个新数组
  
  map -- 对数组的每一项进行操作，返回新数组
  
  some  -- 判断数组中是否有满足条件的元素 如果有返回true 没有 false
  
  every -- 判断数组中是否元素是否全部满足条件 如果是返回true 否则 false
  
  indexOf --  查找第一个符合条件的下标，查到不到返回-1
  
  lastIndexOf --  查找最后一个符合条件的下标，查到不到返回-1
  
  findIndex -- 查找第一个符合条件的下标，查到不到返回-1 
  
  find  -- 查找第一个符合条件的元素，查到不到返回undefined
  
  includes -- 是否包含某个元素  如果包含 true;否则 false
  
- 多维数组转化为一维数组

  判断是不是一个数组如果是就接着循环，不是就push新数组

  第一步：循环数组

  第二步：判断当前值是不是一个数组

  第三步：如果当前值是一个数组，就再次循环，进行判断，甚至不是一个数组

  第四步：如果不是一个数组，就push进新数组

- 闭包
  闭包(closure)是一个函数以及其捆绑的周边环境状态 (lexicalenvironment，词法环境)的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。

  概念: 其实是打通函数内部与函数外部链接一个桥梁，是函数外部拿到函数内部的变量*
  * 特点:

    1.函数嵌套函数

    2.有返回值

    3.返回值是一个回调函数

    优点:- 使用闭包的优点是可以避免全局变量污染，延长变量生命周期。缺点是由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大所以不能滥用闭包，否则会造成网页的性能问题，在低版本IE中***可能导致内存泄露***解决方法是，在退出函数之前，将不使用的局部变量全部删除function person() {

    let name =  peter';
    return function displayName() {

    console.log(name);

    }

    }

    let peter = person();
    peter(); // prints'Peter

    # 原型

    通常，我们写一个构造函数都是这样：

    注意: 构造函数的首字母一定是大写的

    我们不在这个构造函数里写任何代码，当我们在浏览器控制台通过`console.dir`打印出这个构造函数时，可以看到它被添加了一个属性`prototype`。

    通过new创建的实例上有一个`__proto__`属性（注意⚠前后是两个下划线）可以直接访问原型对象`Person.prototype`。通常，我们将`__proto__`属性称为**隐式原型属性**。

    # 原型链

    当我们需要读取实例上的属性时，JS会先在当前实例上查找是否有该属性，如果没有则通过`__proto__`访问原型去查找是否有该属性，如果有的话就可以直接使用，没有的话，就会再通过`__proto__`去访问原型的原型，因为原型也是一个对象嘛。

    `Person.prototype`可以看做是`Object`的实例，这样的话`Person.prototype`通过`__proto__`访问的是`Object`的原型`Object.prototype`，`Object.prototype`也有一个`__proto__`属性，只不过这次不套娃了，它指向的是`null`。

    **总结一下：当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`。**

  * 什么是原型？

    **原型是function对象的一个属性，定义了构造函数创造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。**

    什么是prototype?

       **显示原型，是函数（不包含箭头函数）本身存在的一个属性，他指向的是一个对象，即为原型对象。**

    什么是 __ proto __ ?

    **可以称为隐式原型，或者叫连接点。是对象的一个属性，它里面存储的是该构造函数的原型对象，即prototype.**

    什么是构造函数？

    **构造函数其实是一种特殊的函数，主要用来初始化对象，也就是为对象成员变量赋初始值，它总与new关键字一起使用**

    什么是原型链？

    **当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`。**



1. 事件循环

事件循环是一门单线程的语言，他是自上而下的，他是先执行同步的再执行异步的，先执行同步的，发现异步把异步放到队列里面。将同步执行完成之后再执行异步的，异步又分为宏任务和微任务，宏任务包含一些浏览器的dom操作、ajax请求、settimeout定时器。微任务有promise、asyce和aweit。一般都是先执行宏任务再执行微任务，但是在spritp标签里面先执行微任务再执行宏任务



## 为什么要有this

- 在常见的编程语言中，几乎都有this这个关键字（Objective-C中使用的是self），但是JavaScript中的this和常见的面向对象语言中的this不太一样：

  - 常见面向对象的编程语言中，比如Java、C++、Swift、Dart等等一系列语言中，this通常只会出现在类的方法中。

  - 也就是你需要有一个类，类中的方法（特别是实例方法）中，this代表的是当前调用对象。

  - 但是JavaScript中的this更加灵活，无论是它出现的位置还是它代表的含义。

  - ## this的绑定规则

    ```
    this的绑定和定义的位置（编写的位置）没有关系；
    
    this的绑定和调用方式以及调用的位置有关系；
    ```

    - 绑定一：默认绑定；

      - 独立的函数调用，我们可以理解成函数没有被绑定到某个对象上进行调用；（this指向window）

        绑定二：隐式绑定；

        - 也就是它的调用位置中，是通过某个对象发起的函数调用(谁调用this指向谁)

        - 绑定三：显示绑定；

          - 必须在调用的对象内部有一个对函数的引用（比如一个属性）；
          - 如果没有这样的引用，在进行调用时，会报找不到该函数的错误；
          - 正是通过这个引用，间接的将this绑定到了这个对象上
          - 绑定四：new关键字

          ​       指向实例话对象（除非构造函数返回一个引用类型，则new失效。this指针绑定变为返回的引用类型）

          - 绑定五：箭头函数的绑定

          ​       箭头函数就比较特殊了，他没有明确的指向，他里面的 this 其实是根据他的上级来定的，也就是他的 this 指向等于他的上级。

          ## 优先级

          箭头函数、new、bind、apply 和 call、欧比届点（obj.）、直接调用。

          

          

           实现继承的方法
          * 1.原型继承
          优点:通过原型继承多个引用类型的属性和方法*缺点:Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该用值就会被应用到所有Sub创建的实￥盗用构造函数*2.
          优点:每个实例都会有自己的a属性，哪怕是引用值也不会被污染缺点:Super构造函数中的方法在每个实例上都要创建一遍(除非该方法声明提到全局);Sub的实例无法访问Super原型上的方法组合继承
          *3.
          优点:集合了[原型继承]和[盗用构造函数继承]的优点
          缺点: 存在效率问题，Super始终会被调用两次
          *4原型式继承

          深拷贝浅拷贝

          1:什么是深拷贝
          2:什么是浅拷贝
          另外创建一个一摸一样的对象，新对象跟原对象不共享内存，修改新对象不会更改原对象只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共存一块内存

          要实现一个深拷贝* 
          
          1.写一个函数
          
          2.判断当前传入值的数据类型，RegExp正则不需要拷贝不是对象不需要拷贝
          
          3，最终生成一个对象的构造器* 
          
          4。进行进行赋值* 
          
          5，返回当前的值
          
          
          
          
          
          **1.** ***\*数组\****
          
          ​    什么是数组：一个又一个元素 组成的 有序 的集合
          
             数组取值 需要使用下标 下标从0开始
          
          ​		数组的长度  数组.lenght
          
          声明数组的两种：
          
          1.字面量声明数组
          
          2.构造函数声明
          
          
          
          **1.** ***\*伪数组\****
          
          伪数组也是类数组和数组相似，有数组的长度树型，但是没有数组原型链上的操作方法
          
          常见的伪数组有：***\*arguments\**** ***\*node\*******\*L\*******\*ist\****
          
          // 伪数组转化为  数组 
          
           var a  = Array.prototype.slice.call(伪数组)
          
          // var a  = [].slice.call(伪数组)
          
          //  [...伪数组]
          
          
          
          区别：Array.prototype
          伪数组没有Array.prototype，它只是一个对象
          数组有Array.prototype，他是对象的同时，也是数组
          索引（index）和长度（length）
          伪数组的索引，就是那些键值对的key，没有真正的顺序可言；长度是手动设置的
          数组的索引和长度是内置属性
          
          
          
          **伪数组转真数组**
          
          Array.from()
          
           slice() 
          
          concat() 
          
          利用for循环遍历 
          
          扩展运算符
          
          
          
          
          
          获取DOM节点的方式：
          **
          
          1. 通过ID获取节点 【返回具体某个节点】
            document.getElementById(ID名)
            2.通过标签名获取节点 【返回节点数组，即使只有一个】
            document.getElementsByTagName(标签名)
            3.通过标签的name值获取节点 【返回节点数组】
            document.getElementsByName(Name名)
            4.通过class值来获取节点 【返回节点数组】
            document.getElementsByClassName(Class名)
            5.根据选择器返回找到结果集中的第一个
            document.querySelect(“选择器”)
            6.根据选择器返回找到的结果集，是个节点数组
            document.querySelectAll(“选择器”)
          
            7.特殊元素获取
                   doucumnet.body
                   返回body元素对象
          
            8. HTML元素获取
                   document.documentElement
                   html元素对象
          
          
          
          
          
          
          
          **arguments是一个对应传递给函数参数的类数组对象**；
          
          **使用场景：针对同一个方法被多处调用，但是参数数量不确定的情况下，可以更具arguments索引进行判断。**
          
          1、arguments对象是所有非箭头函数都有的一个局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。
          
          2、arguments对象并不是一个[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)，他除了length和索引元素之外，任何数组的属性都没有。
          
          3、arguments存在属性callee
          
          
          
          （arguments 是一个对应于传递给函数的参数的类数组对象。
          
          arguments对象是所有(非箭头)函数中都可用的局部变量.
          
          可以使用arguments对象在函数中引用函数的参数.索引从0开始.
          
          arguments对象是一个伪数组. 除了length和索引外,不能用任何数组的方法）
          
          // ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments// ES5 获取实参的方式
          function date(){console.log(arguments);
          date("白芷'，阿娇 ，思慧');
          // rest 参数
          function date(...args){console.log(args);// filter some every map
          date("阿娇 ，柏芝 ，思慧');
          // rest 参数必须要放到参数最后function fn(a,b,...args)[console.log(a);console.log(b);console.log(args);
          
          fn(1,2,3,4,5)
          
          
          
          
          
          Promise出现的原因
          1，为了解决异步回调问题
          2.为了解决信任问题(第三方回调函数是不是只执行一次，性能，和执行多次)
          3，为了解湛回调执行顺序问题()
          4.为了解决捕捉错误能力(400 500 )
          2.Promise
          概念: Promise是一个容器，里面存放着异步事件，
          语法: Promise是一个对象，可以获取异步操作的消息
          3，特点
          1.有三种状态: pedding(等待中)， fulfilled(已成功)，rejected(已失败)
          2.状态的变化:
          2.1 从等待中到已成功 (pedding -> fulfilled)
          2.2 从等待中到已失败 (pedding -> rejected)
          3.一旦状态确定，便不在更改,状态凝固--->resolved，无论什么时候监听我 我就是这个样子4。promise的返回值无论是不是promise函数,最终都会被封装promise函数进行返回,需要我们用then方法获取到结果
          5.链式调用
          4.和事件循环的区别事件循环一旦错过，不会再被监听到promise状态凝固，永远都可以被监听到
          5，Promise的回调参数1.resolve -> 成功的回调2.reject -> 失败的回调
          
          
          
          
          
           1.作用域
          全局作用域
          
          函数作用域
          块级作用域(Let const)
          
          let
          特点:
          1，变量不能重复声明(特指:当前作用域不能进行重复声明,在下一个作用域的时候可以重复声明)
          2.块儿级作用域
          3.不存在变量提升
          不影响作用域链
          
          .Const
          特点:
          1.声明一个常量,切不可更改
          2.一般常量用大写(潜规则)
          3.块儿级作用域
          4.对于数组和对象的元素修改,不算做对常量的修改,不会报错1.因为只是修改了内容,并没有修改指针
          
          
          
          总结:
          1.块级作用域
          2.声明常量不可更改，约定俗成用大学来表示(重点:声明基本数据类型不可更改2.声明复杂数据类型，值可以更改,因为堆和栈,复杂数据类型,只是修改了堆中间的内容，栈的引用并没有变)
          
          
          
          作用域链:作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。
          在es6之前只有全局作用域链,和函数作用域链,只有在es6才有了 块级作用域
          
          
          
          
          
          6.箭头函数
          es6 允许使用0=>定义函数
          特点:
          1.this是动态的，this 的值取决于函数本身如何被调用2.没有arguments伪数组如果有绝对是来自于父组件3.不能作为构造实例化对象
          
          （普通函数和箭头函数this指向不同
          1.普通函数this通常是谁调用，this指向谁
          2.箭头函数this本身没有this,它的this通常是父级有function那个函数运行的this
          2.箭头函数不能实例化 (不能new)
          3.箭头函数没有arguments）
          
          
          
          解构赋值分为两种
          1，数组解构
          1.以下标来进行解构，有序结构，不能单独解构出一个值
          2.对象结构*
          1，以属性名来进行解构，可以单独解构任何一个属性
          
          
          
          原型继承
          
          优点: 通过原型继承多个引用类型的属性和方法
          缺点:Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题
          
          
          
          原型链
          当我们需要读取实例上的属性时，JS会先在当前实例上查找是否有该属性，如果没有则通过 proto- 访问原型去查找是否有该属性如果有的话就可以直接使用，没有的话，就会再通过 __proto_ 去访问原型的原型，因为原型也是一个对象嘛。
          Person.prototype"可以看做是 ject 的实例，这样的话 Person.prototype 通过 _-proto__ 访的是 bject 的原型Object.prototype， object.prototype 也有一个 _-proto__ 属性，只不过这次不套娃了，它指向的是 null 。
          总结一下:当我们访问一个实例(例如person)的属性或方法时，会先在当前 实例 上查找，若查找不到，会到 原型 上查找，若原型上查找不到，就到 原型的原型 上查找，若还是查找不到就指向 null
        
        原型式继承
        
        优点:对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性
        缺点:无法判断实例的构造函数是父类还是子类
        
        盗用构造函数
        
        优点: 每个实例都会有自己的a属性，哪怕是引用值也不会被污染
        缺点:Super构造函数中的方法在每个实例上都要创建一遍(除非该方法声明提到全局);Sub的实例无法访问Super原型上的方法

