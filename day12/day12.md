# vue检测数据

1、Vue监视数据的原理

vue会监视data中所有层次的数据。

2、如何监测对象中的数据？

通过setter实现监视，且要在new Vue时就传入要监测的数据

对象中后追加的属性，Vue默认不做响应式处理

如需给后添加的属性做响应式，可以使用一些API：vue.set vm.$set

3、如何监测数组中的数据？

通过包裹数组更新元素的方法实现，本质就是做了两件事

1. 调用原生对应的方法对数组进行更新。
2. 重新解析模板，进而更新页面。

4、在Vue修改数组中的某个元素一定要用到这些方法:

1.使用这些API:  push()、pop()、shift()、unshift()、splice()、sort()、reverse() 

2.Vue.set() 或 vm.$set()

需要注意：

Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性

# vue数据更新时的问题

直接修改数组/对象元素是无法触发视图更新的

vue触发视图更新的方法有如下几种：

1. Vue.set  可以设置对象或数组的值，
  通过key或数组索引，可以触发视图更新

  返回设置的值

  用法：向响应式对象中添加一个property,并确保这个新property同样是响应式的,且触发试图更新
  它必须用于向响应式对象上添加新的property,因为Vue无法探测普通的新增 property

2. Vue.delete  删除对象或数组中元素，
  通过key或数组索引，可以触发视图更新

  用法：删除对象的属性

3. 数组对象直接修改属性，可以触发视图更新

4. splice方法修改数组，可以触发视图更新

  参数：index: 数组下标
  			len: 替换/删除的长度
  			item: 替换的值,删除操作的话 item为空

5. 数组赋值为新数组，可以触发视图更新

6. 用Object.assign或lodash.assign可以为对象添加响应式属性，可以触发视图更新

7. Vue提供了如下的数组的变异方法，可以触发视图更新

  push()
  pop()
  shift()
  unshift()
  splice()  
  sort()
  reverse()

  # 过滤器

  过滤器有两种：全局过滤器vue.filter

  ​							局部过滤器选项式API--filters

  定义：对要显示的数据进行特定格式化后再显示 (适用于一些简单逻辑的处理)

  注意：1.过滤器也可以接收额外参数、多个过滤器也可以串联

  2.并没有改变原本的数据，是产生新的对应的数据

  # Vue的内置指令

  v-text

  作用：向其所在的节点中渲染文本内容。

  v-html指令

  作用：向指定节点中渲染包含html结构的内容。

  v-cloak指令(没有值)

  1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。

  2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。

  v-once指令

   1.v-once所在节点在初次动态渲染后，就视为静态内容。

  2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能

  v-pre指令

  1. 跳过其所在节点的编译过程。
  2.   2.可利用它跳过：没有使用指令语法，没有使用插值语法的节点，会加快编译。

  v-bind

  单向绑定解析表达式，可简写 :xxx

  V-model

  双向数据绑定

  v-on

  绑定事件监听，可简写@

  v-if

  条件渲染（动态控制节点是否存在）

  v-else

  条件渲染（动态控制节点是否存在）

  v-show

  条件渲染（动态控制节点是否展示）

  v-for

  遍历数组/对象/字符串

  # vue生命周期

  每一个vue实例从创建到销毁的过程，就是这个vue实例的生命周期

  vue生命周期可以分为八个阶段。

  1、创建前（beforeCreate）

  当执行 beforeCreate 生命周期函数时，vue 实例还没有被完全创建出来，此时 data，methods 等内部没有初始化，无法获取响应数据。

  2、创建后（created）

  执行这个函数的时候，vue 实例已经初始化了，可以在这里调用数据，不过还没渲染到页面上。 在当前函数中我们可以访问到 data 中的属性，此时，会将 data 中的属性和 methods 的方法添加到 vue 的实例身上，同时会将 data 中所有的属性添加一个 getter/setter 方法。这里可以进行前后端上数据交互(ajax请求的时候) 需要在当前生命周期中使用。有 this props，不能访问 dom(还没有渲染完毕)。常用于自动 ajax 请求、事件监听、定时器开启等。

  3、beforeMount( 挂载前)

  这个时候，vue 已经将模板字符串编译成内存虚拟DOM，模板已经编译完成，已经完成渲染树，还没有渲染到页面上。可以获取初始数据，实现函数自执行。

  4、Mounted( 挂载后)

  创建阶段完成，页面渲染完毕，进入运行阶段。此时我们可以通过$ refs 来访问到真实的DOM 结构，即可以访问 dom 节点。ref 类似与 id 一样 值必须是唯一的，访问的时候我们可以使用this.$refs.属性，可以进行用户交互操作方法。

  5、beforeUpdate（更新前）

  更新前状态（view层的数据变化前，不是data中的数据改变前），重新渲染之前触发，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染。只有view上面的数据变化才会触发beforeUpdate和updated，仅属于data中的数据改变是并不能触发。

  6、updated（更新后）

  数据已经更改完成，dom也重新加载完成。

  7、beforeDestroy（销毁前）

  触发这个函数时，还没开始销毁，此时刚刚脱离运行阶段。data，methods，指令之类的都在正常运行。用于移除 dom 事件监听、定时器等。

  8、destroyed（销毁后）

  组件销毁完毕，data，methods，指令之类的不可用。 
  （这个时候Dom元素存在，只是不再受vue控制）,卸载watcher，事件监听，子组件。

# 收集表单数据

 1.没有配置input的value属性，那么收集的就是checked(勾选 or 未勾选，是布尔值)

2.配置了input的value属性：

（1）v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）

（2）v-model的初始值的数组，那么收集的就是value组成的数组

v-model的三个修饰符：

lazy:失去焦点再收集数据

number:输入字符串转为有效的数字

trim:输入首尾空格过滤

# Vue自定义指令

1、自定义局部指令

在选项式API中的directives中设置。

2、自定义全局指令

在app里写的directive方法。

3、指令的生命周期

created: 在绑定元素的attribute或者事件监听器之前被使用

beforeMount：当指令第一次绑定元素，并且挂载父组件之前被使用。

mounted: 在绑定元素的组件被挂载后调用。

beforeUpdate: 在指令绑定的组件更新其Vnode之前被调用

updated: 在包含组件的 VNode 及其子组件的 VNode 更新后调用

beforeUnmount: 在卸载绑定元素的父组件之前调用

unmounted: 当指令与元素解除绑定且父组件已卸载时，只调用一次。

4、生命周期的参数

el: 表示当前的元素

bindings: 可以从中取出一些参数的内容

vnode: 可以获取当前的vnode节点。

preVnode: 可以获取之前的vnode节点。